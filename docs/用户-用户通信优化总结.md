# 用户-用户通信优化总结

## 已完成的优化

### 1. ✅ 修复用户-用户通信时不显示思考等待消息框

**问题**：发送方发送消息后，会短暂显示思考等待消息框（类似用户-agent对话中的处理）。

**修复**：
- 在 `messages.tsx` 中，添加检查：只有当 `selectedModelId` 不是用户类型（不以 `user::` 开头）时才显示 `ThinkingMessage`
- 在 `chat.tsx` 的 `onData` 回调中，检查最后一条消息是否是用户-用户消息，如果是则不设置 `streaming` 状态

**代码位置**：
- `tribe-frontend/components/messages.tsx:152` - 添加 `!selectedModelId.startsWith("user::")` 检查
- `tribe-frontend/components/chat.tsx:156-163` - 检查 `communicationType === "user_user"` 时不设置 streaming 状态

### 2. ✅ 用户在线状态显示

**实现**：
- 后端 API (`/api/agents?format=simple`) 已正确返回 `is_online` 字段
- 前端 `models-client.ts` 已正确解析 `is_online` 字段
- `model-selector.tsx` 已正确显示用户在线状态（绿色圆点）

**代码位置**：
- `tribe-backend/api/agents_routes.py:160` - 返回 `is_online` 字段
- `tribe-frontend/lib/ai/models-client.ts:59` - 解析 `is_online` 字段
- `tribe-frontend/components/model-selector.tsx:203-205` - 显示在线状态

### 3. ✅ 用户-用户消息发送流程优化

**实现**：
- **在线消息**：通过 SSE 实时推送（`chat_agent.py:597`）
- **离线消息**：先保存到数据库（`delivered=FALSE`），等收信用户登录后拉取

**代码位置**：
- `tribe-backend/agent/chat_agent.py:530-631` - 检查用户在线状态，在线则实时推送，离线则保存
- `tribe-backend/utils/user_base.py:253-294` - 保存消息到数据库
- `tribe-backend/api/routers.py:557-613` - 离线消息拉取接口

### 4. ✅ 离线消息拉取机制

**实现**：
- 后端提供 `/api/chat/offline_messages` 长轮询接口
- 用户登录时，后端会调用 `collect_pending_messages` 获取离线消息
- 前端通过 SSE 接收用户-用户消息（包括离线消息）

**代码位置**：
- `tribe-backend/api/routers.py:557-613` - 离线消息拉取接口
- `tribe-backend/utils/user_base.py:339-363` - 收集并格式化离线消息
- `tribe-frontend/hooks/use-sse-messages.ts` - SSE 消息接收

## 当前实现状态

### 消息发送流程

1. **用户发送消息**：
   - 前端调用 `/api/chat` 接口
   - 后端检查接收者是否在线
   - 如果在线：保存消息 + 通过 SSE 实时推送
   - 如果离线：保存消息（`delivered=FALSE`）

2. **消息接收流程**：
   - **在线消息**：通过 SSE 实时接收并显示
   - **离线消息**：用户登录时，后端通过 `collect_pending_messages` 获取，并通过 SSE 推送

### 在线状态管理

- 后端通过 `members.is_online` 字段跟踪用户在线状态
- 用户登录时调用 `mark_online` 标记在线
- 用户下线时调用 `mark_offline` 标记离线
- 前端通过 `/api/agents` 接口获取用户列表时，包含在线状态

## 注意事项

1. **离线消息标记**：
   - 离线消息在保存时会添加 `（离线消息）` 后缀（`user_base.py:350-351`）
   - 消息被拉取后会标记为 `delivered=TRUE`

2. **SSE 连接**：
   - 前端通过 `useSSEMessages` hook 管理 SSE 连接
   - 连接建立后，会自动接收用户-用户消息
   - 包括实时消息和离线消息（通过 SSE 推送）

3. **消息去重**：
   - 前端在 `chat.tsx` 中处理 SSE 消息时，会检查消息是否已存在，避免重复添加

## 后续优化实施

### 1. ✅ 离线消息批量拉取（已实施）

**实现**：
- 创建了 `useOfflineMessages` hook，在 SSE 连接建立后主动拉取离线消息
- 在 `chat.tsx` 中集成离线消息拉取功能
- 拉取的离线消息会自动转换为 `ChatMessage` 格式并添加到消息列表
- 包含去重逻辑，避免重复添加消息

**代码位置**：
- `tribe-frontend/hooks/use-offline-messages.ts` - 离线消息拉取 hook
- `tribe-frontend/components/chat.tsx:230-285` - 集成离线消息拉取

**关键逻辑**：
- 只有登录用户（`session.user.type === "regular"`）才会拉取离线消息
- 访客状态（`type === "guest"`）不会触发拉取，避免不必要的请求
- 在用户登录成功且 SSE 连接建立后触发，确保时机正确

**工作流程**：
1. 用户登录成功后（`session.user.type === "regular"`），且 SSE 连接建立后，`useOfflineMessages` hook 自动触发
2. 访客状态（`type === "guest"`）不会触发离线消息拉取
3. 调用 `/api/chat/offline_messages` 接口拉取离线消息（超时 5 秒）
4. 将离线消息转换为 `ChatMessage` 格式
5. 检查消息是否已存在（避免重复）
6. 添加到消息列表并保存到数据库

**优势**：
- ✅ 确保离线消息不会丢失，即使 SSE 连接失败
- ✅ 主动拉取，不依赖后端推送时机
- ✅ 自动去重，避免重复消息
- ✅ 静默处理错误，不影响用户体验

### 2. ⏳ 在线状态实时更新（待后端支持）

**当前实现**：
- 在线状态通过 `/api/agents` 接口获取
- 需要刷新页面才能看到最新状态

**优化建议**：
- 后端通过 SSE 推送用户在线状态变化事件
- 前端接收状态变化事件，实时更新用户列表中的在线状态
- 需要后端支持：在用户上线/下线时，通过 SSE 推送状态变化事件

**实现方案**（待后端支持后）：
1. 后端在用户上线/下线时，通过 SSE 推送状态变化事件
2. 前端在 `useSSEMessages` hook 中处理状态变化事件
3. 更新 `useChatModels` hook 中的用户在线状态缓存
4. `model-selector.tsx` 自动更新显示

### 3. ⏳ 消息送达确认机制（可选优化）

**当前实现**：
- 在线消息会立即标记为已送达（`delivered=TRUE`）
- 离线消息在拉取后标记为已送达

**优化建议**：
- 前端收到消息后，发送确认消息到后端
- 后端收到确认后，才标记消息为已送达
- 确保消息真正被用户看到，而不是仅仅推送成功

**实现方案**（可选）：
1. 前端收到用户-用户消息后，调用确认接口
2. 后端收到确认后，标记消息为已送达
3. 可以添加重试机制，确保确认消息发送成功

## 总结

### 已完成的优化
- ✅ 修复用户-用户通信时不显示思考等待消息框
- ✅ 用户在线状态显示
- ✅ 用户-用户消息发送流程优化
- ✅ 离线消息批量拉取（新增）

### 待实施的优化
- ⏳ 在线状态实时更新（需要后端支持）
- ⏳ 消息送达确认机制（可选）

### 代码质量
- ✅ 所有代码遵循 Ultracite 规范
- ✅ 类型安全，无 TypeScript 错误
- ✅ 错误处理完善，静默处理非关键错误
- ✅ 代码简洁高效，避免不必要的重复

