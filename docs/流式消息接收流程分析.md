# 流式AI SDK消息接收流程分析

## 一、后端流式消息发送流程

### 1. 消息ID预生成与传递

- **前端**：在 `chat.tsx` 中通过 `generateId` 预生成 assistant 消息 ID
- **传递**：通过 `expected_assistant_message_id` 传递给后端
- **后端使用**：后端使用该 ID 确保消息一致性

### 2. 流式事件序列（JSON SSE格式）

\`\`\`
1. text-start 事件
   - 格式: data: {"type":"text-start","id":"message_id"}
   - 作用: 标记消息开始，前端创建初始消息对象

2. text-delta 事件（多次）
   - 格式: data: {"type":"text-delta","id":"message_id","delta":"文本片段"}
   - 作用: 增量发送文本内容，前端逐步更新消息

3. message-annotations 事件（可选）
   - 格式: data: {"type":"message-annotations","parts":[{"type":"reasoning","reasoning":"..."}]}
   - 作用: 发送 reasoning 等附加信息

4. finish 事件
   - 格式: data: {"type":"finish","finishReason":"stop","usage":{...}}
   - 作用: 标记流式响应完成，包含 usage 统计

5. data-appendMessage 事件（自定义）
   - 格式: data: 2:{"type":"data-appendMessage","data":{完整消息对象}}
   - 作用: 发送包含完整 metadata 的消息对象
\`\`\`

### 3. 后端处理流程（stream_routes.py）

\`\`\`python
# 1. 发送 text-start（JSON SSE格式需要）
yield format_text_start_event(message_id)

# 2. 流式处理 Agent 响应
async for chunk in agno_agent.arun(user_message, stream=True):
    # 2.1 处理 reasoning（优先）
    if reasoning_content:
        yield format_ai_sdk_sse(reasoning_chunk, use_data_stream_protocol=False)
    
    # 2.2 处理工具调用
    if tool_calls:
        yield format_ai_sdk_sse(tool_call_chunk, use_data_stream_protocol=False)
    
    # 2.3 批量发送文本增量（50ms间隔或缓冲区达到10字符）
    if should_send:
        yield format_ai_sdk_sse(text_chunk, use_data_stream_protocol=False)

# 3. 发送 text-end（JSON SSE格式需要）
yield format_text_end_event(message_id)

# 4. 发送 finish 事件
yield format_finish_event(finish_reason="stop", usage=usage_stats)
\`\`\`

### 4. 格式转换（ai_sdk_adapter.py）

\`\`\`python
# 内部 chunk → AI SDK 格式
convert_internal_to_ai_sdk_chunk(
    content="文本内容",
    message_id="消息ID",
    chunk_type="text|tool_call|reasoning|error",
    **kwargs
)

# AI SDK 格式 → SSE 字符串
format_ai_sdk_sse(chunk, use_data_stream_protocol=False)
# 返回: "data: {JSON格式}\n\n"
\`\`\`

## 二、前端接收和处理流程

### 1. 请求发送（chat.tsx）

\`\`\`typescript
// useChat hook 配置
useStreamChatWithRetry({
  transport: new DefaultChatTransport({
    api: "/api/chat",
    prepareSendMessagesRequest(request) {
      // 预生成 assistant 消息 ID
      expectedAssistantMessageIdRef.current = generateUUID();
      return {
        body: {
          expected_assistant_message_id: assistantMessageId,
          ...
        }
      };
    }
  }),
  onData: (dataPart) => {
    // 收集所有 data 事件到 dataStream
    setDataStream((ds) => [...ds, dataPart]);
  },
  onFinish: () => {
    // 流式响应完成
  }
});
\`\`\`

### 2. 中间层处理（route.ts）

\`\`\`typescript
// 拦截后端 SSE 流，添加 metadata
const { readable, writable } = new TransformStream();

// 1. 检测 text-start，立即发送 data-appendMessage（包含 metadata）
if (parsed.type === "text-start" && parsed.id) {
  const initialMessage = {
    id: assistantMessageId,
    role: "assistant",
    parts: [],
    metadata: fixedMetadata, // 包含 senderName, receiverName 等
  };
  await writer.write(`2:{"type":"data-appendMessage","data":${JSON.stringify(initialMessage)}}\n`);
}

// 2. 收集 text-delta，累积文本内容
if (parsed.type === "text-delta" && parsed.delta) {
  messageTextBuffer += parsed.delta;
}

// 3. 检测 finish，保存消息并发送最终 data-appendMessage
if (parsed.type === "finish") {
  const completeMessage = {
    id: assistantMessageId,
    role: "assistant",
    parts: [{ type: "text", text: messageTextBuffer }],
    metadata: fixedMetadata,
  };
  await writer.write(`2:{"type":"data-appendMessage","data":${JSON.stringify(completeMessage)}}\n`);
  await saveMessages(...); // 保存到数据库
}
\`\`\`

### 3. 消息更新（chat.tsx）

\`\`\`typescript
// 处理 data-appendMessage 事件，更新消息 metadata
useEffect(() => {
  const appendMessageEvents = dataStream.filter(
    (part) => part.type === "data-appendMessage"
  );
  
  appendMessageEvents.forEach((dataPart) => {
    const messageWithMetadata = JSON.parse(dataPart.data);
    // 更新 messages 中对应消息的 metadata
    setMessages((prevMessages) => {
      // 查找并更新消息
      const updatedMessages = [...prevMessages];
      updatedMessages[existingMessageIndex] = {
        ...existingMessage,
        metadata: {
          ...existingMetadata,
          ...messageWithMetadata.metadata,
        },
      };
      return updatedMessages;
    });
  });
}, [dataStream]);
\`\`\`

## 三、标准AI SDK流式消息格式要点

### 1. 两种格式

- **JSON SSE 格式**（当前使用）
  - `data: {"type":"text-start","id":"..."}`
  - `data: {"type":"text-delta","delta":"..."}`
  - `data: {"type":"finish","finishReason":"stop"}`
- **Data Stream Protocol 格式**（Phase 4）
  - `data: 0:"文本内容"`
  - `data: 9:{"toolCallId":"...","toolName":"..."}`
  - `data: d:{"finishReason":"stop"}`

### 2. 核心事件类型

| 事件类型 | 格式 | 作用 |
|---------|------|------|
| `text-start` | `{"type":"text-start","id":"..."}` | 消息开始 |
| `text-delta` | `{"type":"text-delta","delta":"..."}` | 文本增量 |
| `text-end` | `{"type":"text-end","id":"..."}` | 消息结束 |
| `finish` | `{"type":"finish","finishReason":"stop"}` | 完成标记 |
| `message-annotations` | `{"type":"message-annotations","parts":[...]}` | 附加信息（reasoning等） |
| `data-appendMessage` | `2:{"type":"data-appendMessage","data":{...}}` | 自定义：完整消息对象 |

### 3. 关键要点

- **消息ID一致性**：前端预生成，后端使用，确保 `text-start`、`text-delta`、`finish` 使用相同 ID
- **Metadata 传递**：通过 `data-appendMessage` 在流式过程中传递完整 metadata（senderName、receiverName 等）
- **批量优化**：后端每 50ms 或缓冲区达到 10 字符时批量发送文本增量
- **错误处理**：通过 `error` 事件类型传递错误信息
- **心跳机制**：每 30 秒发送心跳保持连接

### 4. 消息生命周期

\`\`\`
用户发送消息
  ↓
前端预生成 assistant 消息 ID
  ↓
后端接收，发送 text-start
  ↓
前端 useChat 创建初始消息对象
  ↓
后端流式发送 text-delta（多次）
  ↓
前端逐步更新消息内容
  ↓
后端发送 data-appendMessage（包含 metadata）
  ↓
前端更新消息 metadata（senderName、receiverName 等）
  ↓
后端发送 finish 事件
  ↓
前端 onFinish 回调，完成流程
\`\`\`

## 四、左侧消息渲染顺序分析

### 1. 消息渲染时间线

\`\`\`
T0: 用户发送消息
  ↓
T1: 前端预生成 assistant 消息 ID（chat.tsx:117）
  ↓
T2: 后端发送 text-start 事件（stream_routes.py:532）
  ↓
T3: useChat 收到 text-start，创建初始消息对象（无 metadata 或 metadata 不完整）
  ↓
T4: React 渲染消息组件（第一次渲染，message.tsx）
     - 此时 metadata 可能为空或不完整
     - senderName 回退到默认值"智能体"
  ↓
T5: 中间层检测到 text-start，发送 data-appendMessage（包含完整 metadata）
    （route.ts:610，异步写入）
  ↓
T6: onData 回调收集 data-appendMessage 到 dataStream（chat.tsx:132）
  ↓
T7: useEffect 处理 data-appendMessage，更新 messages 中的 metadata（chat.tsx:179-267）
  ↓
T8: React 重新渲染消息组件（第二次渲染，此时应有正确的 metadata）
     - metadata.senderName = "司仪"
     - senderName 正确显示
\`\`\`

### 2. 问题分析

**问题现象**：左侧接收 agents 消息时，创建时正确渲染的消息名称（如"司仪"），被错误渲染为"智能体"（刷新页面后正常显示，说明这是在接收消息过程中的渲染问题）。

**根本原因**：
1. **竞态条件**：`text-start` 事件触发 useChat 创建消息（T3），但此时消息可能没有 metadata
2. **渲染时机**：React 在 T4 时刻渲染消息，此时 metadata 可能为空或不完整
3. **默认值回退**：在 `message.tsx` 第113行，如果 `metadata.senderName` 和 `metadata.agentUsed` 都为空，会使用默认值 `"智能体"`
4. **延迟更新**：`data-appendMessage` 在 T5 时刻发送，但到达前端并更新 messages 需要时间（T6-T7），导致在 T4 渲染时使用了默认值

**关键时序问题**：
- `text-start` 事件会立即触发 useChat 创建消息并渲染
- `data-appendMessage` 虽然是异步发送的，但可能存在网络延迟或处理延迟
- 即使中间层在检测到 `text-start` 后立即发送 `data-appendMessage`，useChat 可能已经创建并渲染了消息

### 3. 关键代码位置

**message.tsx (第93-114行)**：
\`\`\`typescript
if (isAgent) {
  // Agent消息：优先使用metadata.senderName（已固化），其次使用agentUsed
  senderName = metadata.senderName || metadata.agentUsed;
  
  // 如果metadata中没有名称，从chatModels查找（兼容旧消息或查询失败的情况）
  if (!senderName && needsChatModelsLookup && chatModels.length > 0) {
    // ... 查找逻辑
  }
  
  if (!senderName) {
    // ⚠️ 问题位置：在流式传输过程中，metadata 可能为空
    // 此时会使用默认值"智能体"，而不是实际的 agent ID
    senderName = metadata.agentUsed || selectedModelId || "智能体";
  }
}
\`\`\`

**chat.tsx (第179-267行)**：
\`\`\`typescript
useEffect(() => {
  // 处理 data-appendMessage 事件
  const appendMessageEvents = dataStream.filter(
    (part) => part.type === "data-appendMessage"
  );
  
  appendMessageEvents.forEach((dataPart) => {
    // 更新消息 metadata
    setMessages((prevMessages) => {
      // ... 更新逻辑
      // 这里会更新消息的 metadata，触发重新渲染
    });
  });
}, [dataStream, messages, setMessages]);
\`\`\`

**route.ts (第594-614行)**：
\`\`\`typescript
// 检测消息开始
if (parsed.type === "text-start" && parsed.id) {
  assistantMessageId = parsed.id;
  
  // 立即发送包含 metadata 的 data-appendMessage 事件
  // 这样客户端可以在流式回复开始时就能获取到正确的名称
  // 避免在流式回复过程中显示默认的"智能体"名称
  try {
    const initialMessage: ChatMessage = {
      id: assistantMessageId,
      role: "assistant",
      parts: [],
      metadata: fixedMetadata, // 包含 senderName, receiverName 等
    };
    
    const appendMessageEvent = `2:{"type":"data-appendMessage","data":${JSON.stringify(initialMessage)}}\n`;
    await writer.write(encoder.encode(appendMessageEvent));
  } catch (error) {
    // 静默处理错误，不影响流式响应
  }
}
\`\`\`

### 4. 渲染触发点分析

**可能重新渲染的时间点**：

1. **T4: 第一次渲染（问题出现）**
   - 触发：useChat 收到 `text-start`，创建初始消息对象
   - 状态：messages 数组更新，新增一条 assistant 消息（无 metadata 或 metadata 不完整）
   - 渲染：React 渲染 `PreviewMessage` 组件
   - 问题：此时 `metadata.senderName` 为空，回退到默认值"智能体"

2. **T6: onData 回调触发**
   - 触发：收到 `data-appendMessage` 事件
   - 状态：dataStream 数组更新
   - 渲染：不会直接触发消息组件重新渲染（dataStream 变化不会触发 PreviewMessage 重新渲染）

3. **T7: useEffect 处理 data-appendMessage**
   - 触发：dataStream 变化，useEffect 执行
   - 状态：messages 数组更新，更新对应消息的 metadata
   - 渲染：React 重新渲染 `PreviewMessage` 组件
   - 结果：此时 `metadata.senderName` 已更新为"司仪"，正确显示

4. **T8: 后续 text-delta 事件**
   - 触发：收到 `text-delta` 事件
   - 状态：messages 数组更新，更新消息的 parts
   - 渲染：React 重新渲染 `PreviewMessage` 组件（仅更新内容，名称已正确）

### 5. 解决方案

**方案1：在 useChat 创建消息时预填充 metadata**
- 在 `prepareSendMessagesRequest` 中，除了预生成 ID，还预填充 metadata
- 确保 useChat 创建的消息从一开始就有正确的 metadata
- **问题**：useChat 内部实现可能不支持预填充 metadata

**方案2：优化 data-appendMessage 发送时机**
- 确保 `data-appendMessage` 在 `text-start` 之前或同时发送
- 或者在中间层拦截 `text-start`，先发送 `data-appendMessage`，再转发 `text-start`
- **问题**：需要修改中间层逻辑，可能影响其他功能

**方案3：在 message.tsx 中延迟渲染名称**
- 如果消息正在流式传输中（`isLoading === true`）且没有 metadata，显示加载状态而不是默认值
- 等待 metadata 到达后再显示名称
- **问题**：用户体验可能不好（显示加载状态）

**方案4：使用 selectedModelId 作为临时名称（已实现）**
- 在流式传输过程中，如果 metadata 为空，使用 `selectedModelId` 作为临时名称
- 这样可以避免显示"智能体"，而是显示实际的 agent ID（如"司仪"）
- **优点**：
  - 最小改动：只需修改 `message.tsx` 中的默认值逻辑
  - 用户体验好：显示实际的 agent ID 而不是"智能体"
  - 向后兼容：不影响现有功能

**实现方式**（已实现）：
\`\`\`typescript
if (!senderName) {
  // 流式传输过程中，如果 metadata 为空，优先使用 selectedModelId（发送消息时选中的 agent）
  // 这样可以避免显示"智能体"，而是显示实际的 agent ID（如"司仪"）
  // metadata.agentUsed 可能为空（在 data-appendMessage 到达之前）
  senderName = metadata.agentUsed || selectedModelId || "智能体";
}
\`\`\`

**注意**：
- `selectedModelId` 在流式传输过程中应该是可用的，因为它是在发送消息时确定的（`initialChatModel`）
- 这个方案可以确保在 metadata 到达之前，显示正确的 agent ID，而不是默认值"智能体"

### 6. ThinkingMessage 组件分析

**为什么 ThinkingMessage 能正确显示名称？**

`ThinkingMessage` 组件在等待阶段（`status === "submitted"`）显示，此时消息尚未创建。

**代码位置**：`message.tsx:487-532`

\`\`\`typescript
export const ThinkingMessage = ({
  agentName,
  selectedModelId,
}: {
  agentName?: string;
  selectedModelId?: string;
}) => {
  const displayAgentName = agentName || selectedModelId || "智能体";
  // ...
}
\`\`\`

**关键点**：
1. `ThinkingMessage` 直接使用 `agentName || selectedModelId || "智能体"`
2. 在 `messages.tsx:116-119` 中，传递 `agentName={selectedModelId}`
3. `selectedModelId` 是 `initialChatModel`，在发送消息时确定，始终可用
4. 因此能正确显示 agent 名称（如"司仪"）

**对比 PreviewMessage**：
- `PreviewMessage` 需要从 `message.metadata` 中获取名称
- 在消息刚创建时，`metadata` 可能为空
- 需要通过 `isAgent` 判断，而 `isAgent` 依赖 `metadata.communicationType`
- 如果 `metadata` 为空，`isAgent` 可能判断错误，导致使用默认值"智能体"

### 7. 接收阶段的名称显示和固化逻辑

#### 7.1 临时名称显示（接收阶段）

**目的**：在 `data-appendMessage` 到达之前，显示正确的 agent 名称，避免显示"智能体"。

**实现位置**：`message.tsx:75-76, 118-123, 144-146`

**关键逻辑**：

1. **isAgent 判断增强**（第75-76行）：
\`\`\`typescript
const isAgent = isAgentMessage(message.role, metadata.communicationType) ||
  (message.role === "assistant" && !metadata.communicationType && selectedModelId && !selectedModelId.startsWith("user::"));
\`\`\`
- 如果 `metadata.communicationType` 存在，使用标准判断
- 如果 `metadata` 为空，但 `selectedModelId` 存在且不是 `user::` 开头，则认为是 Agent 消息

2. **临时名称回退**（第118-123行）：
\`\`\`typescript
// 流式传输过程中，如果 metadata 为空，优先使用 selectedModelId（发送消息时选中的 agent）
// 这样可以避免显示"智能体"，而是显示实际的 agent ID（如"司仪"）
// 这是接收阶段的临时名称显示，用于在 data-appendMessage 到达之前显示正确的名称
if (!senderName) {
  senderName = selectedModelId || "智能体";
}
\`\`\`

3. **其他情况的回退**（第144-146行）：
\`\`\`typescript
// 其他情况（可能是metadata为空时的assistant消息）
// 在流式传输过程中，如果metadata为空，使用selectedModelId作为临时名称
senderName = metadata.senderName || metadata.agentUsed || selectedModelId || "智能体";
\`\`\`

**时间线**：
\`\`\`
T0: 用户发送消息，selectedModelId = "司仪"（确定）
T1: useChat 创建消息，metadata = {}（空）
T2: PreviewMessage 渲染
    - isAgent = true（通过 selectedModelId 判断）
    - senderName = selectedModelId = "司仪" ✅（临时名称显示）
T3: data-appendMessage 到达，metadata 更新
T4: PreviewMessage 重新渲染
    - senderName = metadata.senderName = "司仪" ✅（名称固化）
\`\`\`

#### 7.2 名称固化（接收阶段）

**目的**：当 `data-appendMessage` 到达时，将 metadata 中的名称固化到消息对象中。

**实现位置**：`chat.tsx:179-267`

**关键逻辑**：

1. **监听 data-appendMessage 事件**（第182行）：
\`\`\`typescript
const appendMessageEvents = dataStream.filter((part) => part.type === "data-appendMessage");
\`\`\`

2. **更新消息 metadata**（第234-242行）：
\`\`\`typescript
const existingMetadata = existingMessage.metadata || { createdAt: new Date().toISOString() };
updatedMessages[existingMessageIndex] = {
  ...existingMessage,
  metadata: {
    ...existingMetadata,
    ...messageWithMetadata.metadata, // 合并新的 metadata
    createdAt: existingMetadata.createdAt || messageWithMetadata.metadata?.createdAt || new Date().toISOString(),
  },
};
\`\`\`

3. **防重复处理**（第188-192行）：
\`\`\`typescript
const eventKey = `${messageWithMetadata.id}-${messageWithMetadata.role}`;
if (processedMetadataRef.current.has(eventKey)) {
  return; // 已处理过，跳过
}
\`\`\`

**时间线**：
\`\`\`
T3: data-appendMessage 到达
    - messageWithMetadata.metadata = { senderName: "司仪", agentUsed: "司仪", ... }
T4: useEffect 执行，更新 messages
    - existingMessage.metadata = {}（空）
    - updatedMessage.metadata = { senderName: "司仪", agentUsed: "司仪", ... } ✅（名称固化）
T5: React 重新渲染 PreviewMessage
    - senderName = metadata.senderName = "司仪" ✅（使用固化后的名称）
\`\`\`

### 8. 问题根本原因和解决方案

#### 8.1 问题根本原因

1. **isAgent 判断依赖 metadata**：
   - 当 `metadata.communicationType` 为空时，`isAgent` 可能为 `false`
   - 导致不会进入 Agent 消息的处理逻辑，使用默认值"智能体"

2. **metadata 为空时的回退逻辑不完善**：
   - 原代码：`senderName = metadata.agentUsed || selectedModelId || "智能体"`
   - 如果 `metadata.agentUsed` 存在但为空字符串，仍会使用它（falsy 值问题）

3. **selectedModelId 未充分利用**：
   - `selectedModelId` 在发送消息时确定，始终可用
   - 但在原代码中，只在最后回退时使用，优先级不够高

#### 8.2 解决方案

**方案1：增强 isAgent 判断**（已实现）
- 当 `metadata.communicationType` 为空时，使用 `selectedModelId` 判断
- 如果 `selectedModelId` 存在且不是 `user::` 开头，则认为是 Agent 消息

**方案2：优化临时名称回退**（已实现）
- 在 Agent 消息处理中，直接使用 `selectedModelId` 作为临时名称
- 移除 `metadata.agentUsed` 的中间判断，避免 falsy 值问题

**方案3：完善其他情况的回退**（已实现）
- 在 `else` 分支中，也添加 `selectedModelId` 作为回退选项

### 9. 验证方法

1. **检查渲染顺序**：
   - 在 `message.tsx` 中添加 console.log，记录每次渲染时的 senderName 和 metadata
   - 观察是否在第一次渲染时使用了 selectedModelId

2. **检查 data-appendMessage 时机**：
   - 在 `route.ts` 中添加日志，记录 `text-start` 和 `data-appendMessage` 的发送时间
   - 在 `chat.tsx` 中添加日志，记录 `data-appendMessage` 的接收时间

3. **检查消息更新**：
   - 在 `chat.tsx` 的 useEffect 中添加日志，记录 metadata 更新的时机
   - 确认 metadata 更新后，消息组件是否重新渲染

4. **检查 isAgent 判断**：
   - 在 `message.tsx` 中添加日志，记录 `isAgent` 的判断结果和依据
   - 确认在 metadata 为空时，是否通过 `selectedModelId` 正确判断

## 十、消息渲染标准逻辑模板

### 1. 核心设计原则

**历史消息固化，仅更新当前消息**

- **历史消息**：已经完成的消息（包括刚发送的用户消息），不应被修改，保持原样
- **当前消息**：正在流式传输的消息，可以更新 metadata 和内容

### 2. 标准消息渲染逻辑模板

**实现位置**：`chat.tsx:175-290`

\`\`\`typescript
// ===== 标准消息渲染逻辑模板 =====
// 1. 界定当前消息和历史消息
//    当前消息：正在流式传输的消息（最后一条 assistant 消息，且 status === "streaming"）
//    历史消息：除当前消息外的所有消息（固化，不应被修改）

const isStreaming = status === "streaming";
const lastMessage = prevMessages[prevMessages.length - 1];
const isCurrentMessage = isStreaming && 
  lastMessage?.role === "assistant" && 
  (lastMessage.id === messageWithMetadata.id || 
   lastMessage.metadata?.originalMessageId === messageWithMetadata.id);

// 2. 保护历史消息：合并固化的历史消息和当前消息列表
//    确保即使用户消息在 prevMessages 中被移除，也能恢复
const frozenHistory = frozenHistoryMessagesRef.current;
const currentMessageIds = new Set(prevMessages.map(m => m.id));

// 找出被移除的历史消息（在固化列表中但不在当前列表中）
const missingHistoryMessages = frozenHistory.filter(
  msg => !currentMessageIds.has(msg.id) && 
  // 排除当前流式消息（如果存在）
  !(isStreaming && lastMessage && msg.id === lastMessage.id)
);

// 合并：当前消息列表 + 被移除的历史消息
const preservedMessages = missingHistoryMessages.length > 0
  ? [...prevMessages, ...missingHistoryMessages]
  : prevMessages;

// 3. 查找要更新的消息（仅限当前消息或匹配的历史消息）
let targetMessageIndex = -1;

if (isCurrentMessage && messageWithMetadata.role === "assistant") {
  // 当前消息：最后一条 assistant 消息
  targetMessageIndex = preservedMessages.length - 1;
} else {
  // 历史消息：通过 ID 查找（用于处理延迟到达的 metadata）
  for (let i = preservedMessages.length - 1; i >= 0; i--) {
    if (preservedMessages[i].id === messageWithMetadata.id ||
        preservedMessages[i].metadata?.originalMessageId === messageWithMetadata.id) {
      targetMessageIndex = i;
      break;
    }
  }
}

// 4. 更新消息（仅更新目标消息，保留所有历史消息）
if (targetMessageIndex >= 0) {
  const targetMessage = preservedMessages[targetMessageIndex];
  const needsUpdate = !targetMessage.metadata || 
    JSON.stringify(targetMessage.metadata) !== JSON.stringify(messageWithMetadata.metadata);
  
  if (needsUpdate) {
    const updatedMessages = [...preservedMessages];
    const existingMetadata = targetMessage.metadata || { createdAt: new Date().toISOString() };
    
    // 仅更新目标消息的 metadata，保留其他所有消息不变（历史消息固化）
    updatedMessages[targetMessageIndex] = {
      ...targetMessage,
      metadata: {
        ...existingMetadata,
        ...messageWithMetadata.metadata,
        createdAt: existingMetadata.createdAt || messageWithMetadata.metadata?.createdAt || new Date().toISOString(),
      },
    };
    
    return updatedMessages;
  }
}

// 5. 如果没有找到匹配的消息，返回保护后的消息列表（历史消息固化）
return preservedMessages;
\`\`\`

### 3. 历史消息固化机制

**实现位置**：`chat.tsx:174-186`

\`\`\`typescript
// 固化历史消息：当 messages 更新时，保存所有历史消息（除当前流式消息外）
const frozenHistoryMessagesRef = useRef<ChatMessage[]>([]);
const lastStreamingStatusRef = useRef<"idle" | "streaming" | "submitted">("idle");

useEffect(() => {
  // 当从非 streaming 状态进入 streaming 状态时，固化当前所有消息为历史消息
  // 这样可以确保在流式传输开始前，所有消息都被保存
  if (lastStreamingStatusRef.current !== "streaming" && status === "streaming") {
    // 进入流式传输状态，固化当前所有消息为历史消息
    frozenHistoryMessagesRef.current = [...messages];
  } else if (status !== "streaming" && messages.length > 0) {
    // 流式传输结束，更新固化的历史消息（包含新完成的消息）
    frozenHistoryMessagesRef.current = [...messages];
  }
  lastStreamingStatusRef.current = status;
}, [messages, status]);
\`\`\`

**关键时机**：
- **进入流式传输时**：固化当前所有消息为历史消息（包括刚发送的用户消息）
- **流式传输结束时**：更新固化的历史消息（包含新完成的消息）

### 4. 逻辑要点

#### 4.1 当前消息识别

**条件**：
- `status === "streaming"`：正在流式传输
- `lastMessage.role === "assistant"`：最后一条消息是 assistant
- `lastMessage.id === messageWithMetadata.id`：ID 匹配

**作用**：
- 明确标识正在流式传输的消息
- 只有当前消息可以更新 metadata 和内容
- 历史消息保持固化状态

#### 4.2 历史消息固化

**原则**：
- 除当前消息外的所有消息都是历史消息
- 历史消息不应被修改、删除或重新排序
- 历史消息的 metadata 可以更新（用于处理延迟到达的 metadata）

**实现**：
- 在进入流式传输时，固化当前所有消息
- 在更新消息时，检查并恢复被移除的历史消息
- 使用 `[...prevMessages, ...missingHistoryMessages]` 合并消息

#### 4.3 消息更新范围

**可更新的消息**：
1. **当前消息**：正在流式传输的 assistant 消息
2. **匹配的历史消息**：通过 ID 匹配的历史消息（用于处理延迟到达的 metadata）

**不可更新的消息**：
- 其他所有历史消息（包括刚发送的用户消息）

### 5. 解决的问题

#### 5.1 右侧用户消息消失问题

**问题**：在左侧接收 agents 消息开始后，右侧用户刚发送的消息消失。

**根本原因分析**：

1. **useChat 内部行为**：
   - 当 `text-start` 事件到达时，useChat 会创建新的 assistant 消息
   - useChat 可能会重新设置 messages 数组，只保留到当前 assistant 消息为止
   - 这导致刚发送的用户消息被意外移除

2. **消息更新时序**：
   - `text-start` 事件触发 useChat 更新 messages
   - `data-appendMessage` 事件的处理是异步的（使用 `requestAnimationFrame`）
   - 在 `data-appendMessage` 处理之前，用户消息可能已经被移除

3. **消息去重逻辑**：
   - `messages.tsx` 中的 `uniqueMessages` 使用 Map 去重
   - 如果消息 ID 相同，后面的会覆盖前面的（但用户消息和 assistant 消息 ID 应该不同）

4. **消息过滤逻辑**：
   - `messages.tsx` 中的过滤逻辑只过滤 assistant 消息，用户消息应该总是通过
   - `message.tsx` 中的 `renderMessageContent` 如果返回 null，整个消息不渲染
   - 但用户消息应该总是有内容，不应该被过滤

**解决方案**：
- 在进入流式传输时，固化当前所有消息为历史消息
- 在更新消息时，检查并恢复被移除的历史消息
- 确保刚发送的用户消息作为历史消息被固化

#### 5.2 消息更新范围问题

**问题**：消息更新时可能影响不应该被修改的消息。

**解决方案**：
- 使用标准逻辑模板，明确更新范围
- 只更新目标消息，其他消息保持不变
- 避免复杂的恢复逻辑

### 6. 优势

1. **逻辑清晰**：明确区分当前消息和历史消息
2. **性能优化**：只更新必要的消息，减少不必要的渲染
3. **稳定性高**：历史消息固化，避免意外修改
4. **易于维护**：标准模板，易于理解和扩展
5. **自动恢复**：自动检测并恢复被移除的历史消息

### 7. 使用场景

**适用场景**：
- 流式消息接收和渲染
- 消息 metadata 更新
- 消息内容增量更新

**不适用场景**：
- 消息删除（需要特殊处理）
- 消息重新排序（需要特殊处理）
- 批量消息更新（需要特殊处理）

### 8. 验证方法

1. **检查消息固化**：
   - 在更新逻辑中添加日志，确认历史消息是否被固化
   - 观察进入流式传输时，消息是否被正确保存

2. **检查消息恢复**：
   - 确认被移除的历史消息是否被正确恢复
   - 观察恢复后的消息顺序是否正确

3. **检查更新范围**：
   - 确认只有目标消息被更新
   - 确认其他消息保持不变

4. **检查消息顺序**：
   - 确认消息顺序在更新后保持不变
   - 确认用户消息和 assistant 消息的配对关系
