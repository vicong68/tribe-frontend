# 前后端数据库统一方案

## 问题分析

### 当前问题

1. **用户表不统一**：
   - **前端**：`User` 表（`id` UUID, `email`, `password`）
   - **后端**：`members` 表（`member_id` VARCHAR(20), `email`, `nickname`, `password_hash`, `is_online`）
   - 两套表，数据不同步，需要维护关联关系

2. **Agent 标识不统一**：
   - **前端**：使用显示名称作为ID（如 "司仪"、"书吏"）
   - **后端静态Agent**：`name` (如 "chat") + `display_names` (如 ["司仪"])
   - **后端动态Agent（yml）**：`name` (如 "Info_Hunter") + `display_names` (如 ["猎手"])
   - 前端只有名称，后端有名称+ID，容易混淆

3. **实体信息管理冗余**：
   - EntityInfoManager 需要维护多套映射关系
   - 需要处理前后端ID转换
   - 查询逻辑复杂

## 统一方案

### 1. 数据库统一设计

#### 方案A：后端数据库为主（推荐）

**统一使用后端 `members` 表，前端 `User` 表作为会话管理表**

**数据库结构**：

```sql
-- 后端 members 表（主表，存储完整用户信息）
CREATE TABLE members (
    id SERIAL PRIMARY KEY,
    member_id VARCHAR(50) UNIQUE NOT NULL,  -- 统一标识符（可以是UUID或自定义ID）
    email VARCHAR(255) UNIQUE NOT NULL,     -- 邮箱（唯一）
    password_hash VARCHAR(255) NOT NULL,    -- 密码哈希
    nickname VARCHAR(100),                  -- 昵称
    user_group VARCHAR(50) DEFAULT '初级',
    introduction TEXT,
    avatar_url VARCHAR(500),
    avatar_icon VARCHAR(10) DEFAULT '👤',
    is_online BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMP,
    last_seen_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 前端 User 表（会话管理表，关联到 members）
CREATE TABLE "User" (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),  -- 前端会话ID
    member_id VARCHAR(50) UNIQUE NOT NULL,          -- 关联到 members.member_id
    email VARCHAR(255) NOT NULL,                    -- 冗余字段（快速查询）
    password VARCHAR(64),                           -- 可选（如果前端需要）
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (member_id) REFERENCES members(member_id) ON DELETE CASCADE
);

-- 创建索引
CREATE INDEX idx_user_member_id ON "User"(member_id);
CREATE INDEX idx_members_email ON members(email);
CREATE INDEX idx_members_member_id ON members(member_id);
```

**关联关系**：
- `User.member_id` → `members.member_id`（一对一）
- 前端通过 `member_id` 关联到后端用户信息
- 前端 `User.id` 仅用于会话管理

#### 方案B：统一使用UUID（备选）

**所有ID统一使用UUID格式**

```sql
-- 统一使用UUID作为主键
CREATE TABLE members (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),  -- 统一UUID
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    nickname VARCHAR(100),
    -- ... 其他字段
);
```

### 2. Agent 标识标准化

#### 统一规则

**Agent 标识规范**：
- **内部ID**：使用 `name` 字段（如 "chat", "rag", "Info_Hunter"）
- **显示名称**：使用 `display_names` 列表（如 ["司仪"], ["猎手"]）
- **前端使用**：统一使用 `name` 作为ID，`display_names[0]` 作为显示名称

**数据库设计**：

```sql
-- Agent 信息表（统一存储所有Agent信息）
CREATE TABLE agents (
    id SERIAL PRIMARY KEY,
    agent_id VARCHAR(100) UNIQUE NOT NULL,  -- 内部ID（如 "chat", "rag", "Info_Hunter"）
    display_name VARCHAR(100) NOT NULL,     -- 主显示名称（如 "司仪", "猎手"）
    display_names JSONB,                    -- 所有显示名称列表
    description TEXT,
    category VARCHAR(50),                   -- 分类（如 "基础服务", "专家团队"）
    agent_type VARCHAR(20) NOT NULL,        -- 类型：'static' | 'dynamic' | 'user'
    config_source VARCHAR(50),              -- 配置来源：'code' | 'yml' | 'db'
    model_provider VARCHAR(50),
    model_id VARCHAR(100),
    tools JSONB,                            -- 工具配置
    knowledge VARCHAR(100),
    status VARCHAR(20) DEFAULT 'online',    -- online, offline, busy
    is_registered BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建索引
CREATE INDEX idx_agents_agent_id ON agents(agent_id);
CREATE INDEX idx_agents_display_name ON agents(display_name);
CREATE INDEX idx_agents_type ON agents(agent_type);
CREATE INDEX idx_agents_status ON agents(status);
```

**Agent 类型说明**：
- `static`：静态Agent（代码中定义，如 "chat", "rag"）
- `dynamic`：动态Agent（yml配置，如 "Info_Hunter"）
- `user`：用户Agent（从 members 表生成）

### 3. 统一后的数据流

#### 用户数据流

```
1. 用户注册/登录
   ↓
2. 后端 members 表创建/更新
   ↓
3. 前端 User 表创建/更新（关联 member_id）
   ↓
4. 前端 session 存储 member_id
   ↓
5. 所有查询使用 member_id
```

#### Agent 数据流

```
1. 系统启动
   ↓
2. 加载静态Agent（代码）→ agents 表
   ↓
3. 加载动态Agent（yml）→ agents 表
   ↓
4. 加载用户Agent（members）→ agents 表（type='user'）
   ↓
5. EntityInfoManager 从 agents 表读取（无需多源查询）
```

### 4. 简化后的 EntityInfoManager

**基于统一数据库的简化设计**：

```python
class EntityInfoManager:
    """实体信息管理器（基于统一数据库）"""
    
    def __init__(self):
        self._agents_cache: Dict[str, AgentEntityInfo] = {}
        self._users_cache: Dict[str, UserEntityInfo] = {}
        self._last_refresh: datetime = None
    
    def refresh_from_db(self, db_connection):
        """从统一数据库刷新所有实体信息"""
        # 1. 从 agents 表加载所有Agent
        agents = self._load_agents_from_db(db_connection)
        
        # 2. 从 members 表加载所有用户
        users = self._load_users_from_db(db_connection)
        
        # 3. 更新缓存
        self._agents_cache = {a.agent_id: a for a in agents}
        self._users_cache = {u.member_id: u for u in users}
        self._last_refresh = datetime.now()
    
    def get_agent(self, agent_id: str) -> Optional[AgentEntityInfo]:
        """根据 agent_id 获取Agent信息（统一使用 name）"""
        return self._agents_cache.get(agent_id)
    
    def get_user(self, member_id: str) -> Optional[UserEntityInfo]:
        """根据 member_id 获取用户信息"""
        return self._users_cache.get(member_id)
```

**优势**：
- 单一数据源（数据库）
- 无需维护多套映射关系
- 查询逻辑简单
- 数据一致性保证

## 实施步骤

### 阶段1：数据库迁移

1. **扩展 members 表**：
   - 确保 `email` 字段唯一
   - 添加 `member_id` 唯一约束
   - 添加索引

2. **修改前端 User 表**：
   - 添加 `member_id` 字段
   - 建立外键关联
   - 迁移现有数据

3. **创建 agents 表**：
   - 创建表结构
   - 迁移现有Agent信息
   - 建立索引

### 阶段2：代码迁移

1. **统一用户ID使用**：
   - 前端统一使用 `member_id`
   - 后端统一使用 `member_id`
   - 移除 `userId` 和 `memberId` 的转换逻辑

2. **统一Agent标识**：
   - 前端统一使用 `agent_id`（name字段）
   - 后端统一使用 `agent_id`
   - 显示名称仅用于UI展示

3. **简化 EntityInfoManager**：
   - 移除多源查询逻辑
   - 统一从数据库读取
   - 简化缓存机制

### 阶段3：测试和优化

1. **数据一致性测试**：
   - 验证前后端数据同步
   - 验证关联关系正确性

2. **性能优化**：
   - 优化数据库查询
   - 优化缓存策略

3. **清理冗余代码**：
   - 移除旧的映射逻辑
   - 移除重复的查询函数

## 迁移策略

### 数据迁移脚本

```sql
-- 1. 为前端 User 表添加 member_id 字段
ALTER TABLE "User" ADD COLUMN IF NOT EXISTS member_id VARCHAR(50);

-- 2. 建立关联关系（基于 email）
UPDATE "User" u
SET member_id = m.member_id
FROM members m
WHERE u.email = m.email;

-- 3. 添加外键约束
ALTER TABLE "User" 
ADD CONSTRAINT fk_user_member_id 
FOREIGN KEY (member_id) REFERENCES members(member_id) ON DELETE CASCADE;

-- 4. 创建 agents 表并迁移数据
-- （需要从代码和yml配置中提取Agent信息）
```

### 代码迁移策略

1. **向后兼容**：
   - 保留旧的API接口
   - 内部使用新的统一逻辑
   - 逐步迁移前端代码

2. **分阶段迁移**：
   - 先迁移用户相关功能
   - 再迁移Agent相关功能
   - 最后清理冗余代码

## 优势

1. **数据一致性**：
   - 单一数据源
   - 避免数据不同步
   - 减少数据冗余

2. **代码简化**：
   - 统一的查询逻辑
   - 减少映射转换
   - 降低维护成本

3. **性能提升**：
   - 减少数据库查询
   - 简化缓存逻辑
   - 提高查询效率

4. **可维护性**：
   - 清晰的关联关系
   - 统一的命名规范
   - 易于扩展

