# 用户在线状态优化方案

## 问题分析

### 当前问题
1. **远端用户在线/离线状态判别不准确**
   - 用户登录/注销后，状态更新不及时
   - 下拉列表中的在线状态可能过时
   - 发送消息时使用的状态可能不准确

2. **状态更新时机不明确**
   - 前端登录/注销时未明确更新后端状态
   - 下拉列表打开时未刷新状态
   - 发送消息时未实时查询收信用户状态

3. **兜底处理不足**
   - 浏览器关闭、网络阻塞等情况未处理
   - 无法正常接收消息时缺少兜底机制

## 优化方案

### 1. 前端登录/注销时更新后端状态

**实现**：
- 登录成功时，调用后端 API 更新在线状态
- 注销时，调用后端 API 更新离线状态
- 使用 NextAuth 的 `signIn` 和 `signOut` 回调

**代码位置**：
- `tribe-frontend/app/(auth)/actions.ts` - 登录成功后更新状态
- `tribe-frontend/components/sidebar-user-nav.tsx` - 注销时更新状态

### 2. 下拉列表打开时刷新在线状态

**实现**：
- 在 `model-selector.tsx` 中，下拉菜单打开时刷新用户列表
- 清除缓存，强制重新获取最新状态
- 使用 `onOpenChange` 回调触发刷新

**代码位置**：
- `tribe-frontend/components/model-selector.tsx` - 下拉打开时刷新
- `tribe-frontend/lib/ai/models-client.ts` - 清除缓存逻辑

### 3. 发送消息时查询收信用户状态

**实现**：
- 在 `/api/chat/route.ts` 中，发送用户-用户消息前查询收信用户状态
- 后端在 `_handle_user_direct_message` 中已查询状态，但需要确保准确性
- 前端可以在发送前预查询，用于UI提示

**代码位置**：
- `tribe-frontend/app/(chat)/api/chat/route.ts` - 发送前查询状态
- `tribe-backend/agent/chat_agent.py` - 后端查询状态逻辑

### 4. 优化在线/离线消息通道切换

**实现**：
- 根据收信用户状态选择消息通道
- 在线：实时推送（SSE + WebSocket）
- 离线：保存到数据库，等待拉取
- 添加兜底：即使在线但无法接收，也保存为离线消息

**代码位置**：
- `tribe-backend/agent/chat_agent.py:530-637` - 消息通道选择逻辑

### 5. 兜底处理机制

**实现**：
- 浏览器关闭：通过 `beforeunload` 事件标记离线
- 网络阻塞：超时后转为离线消息
- SSE 连接断开：定期检查连接状态，断开时标记离线

**代码位置**：
- `tribe-frontend/hooks/use-sse-messages.ts` - 连接状态管理
- `tribe-frontend/components/chat.tsx` - 页面卸载处理

## 实现细节

### 状态更新时机

1. **登录成功**：
   - NextAuth `signIn` 成功后
   - 调用后端 `/api/chat/register?action=login` 更新状态
   - 后端已自动更新 `is_online = TRUE`

2. **注销**：
   - NextAuth `signOut` 时
   - 调用后端 `/api/chat/register?action=logout` 更新状态
   - 后端更新 `is_online = FALSE`

3. **下拉列表打开**：
   - `DropdownMenu` 的 `onOpenChange(true)` 时
   - 清除用户列表缓存
   - 重新获取最新状态

4. **发送消息前**：
   - 查询收信用户当前状态
   - 用于UI提示和消息通道选择

### 状态查询优化

1. **后端状态查询**：
   - 使用 `user_base.is_user_online(recipient_id)` 查询
   - 检查 `members.is_online` 字段
   - 同时检查 SSE/WebSocket 连接状态

2. **前端状态显示**：
   - 下拉列表：绿色圆点（在线），红色圆点（离线）
   - 实时更新：下拉打开时刷新

### 消息通道选择

1. **在线消息**：
   - 条件：`is_online = TRUE` 且 有 SSE/WebSocket 连接
   - 通道：SSE 实时推送 + WebSocket（向后兼容）
   - 标记：推送成功后标记 `delivered = TRUE`

2. **离线消息**：
   - 条件：`is_online = FALSE` 或 无连接
   - 通道：保存到数据库，`delivered = FALSE`
   - 标记：用户登录后拉取时标记 `delivered = TRUE`

3. **兜底处理**：
   - 即使在线，如果推送失败，也保存为离线消息
   - 定期检查连接状态，断开时标记离线
   - 浏览器关闭时标记离线

## 技术实现

### 前端实现

1. **登录状态更新**：
```typescript
// 登录成功后更新状态
if (state.status === "success") {
  // NextAuth 已更新 session
  // 后端登录接口已自动更新 is_online = TRUE
  // 无需额外调用
}
```

2. **注销状态更新**：
```typescript
// 注销时更新状态
const handleSignOut = async () => {
  // 先调用后端更新状态
  await fetch('/api/auth/backend/logout', { method: 'POST' });
  // 然后调用 NextAuth signOut
  await signOut();
};
```

3. **下拉列表刷新**：
```typescript
// 下拉打开时刷新状态
<DropdownMenu onOpenChange={(open) => {
  if (open) {
    // 清除缓存，强制刷新
    clearModelsCache();
    // 重新获取用户列表
    refetchModels();
  }
}}>
```

### 后端实现

1. **状态查询优化**：
```python
# 查询用户在线状态（考虑连接状态）
def is_user_online(self, member_id: str) -> bool:
    # 1. 检查数据库 is_online 字段
    is_online_db = self._check_online_in_db(member_id)
    # 2. 检查是否有活跃连接
    has_connection = sse_manager.has_connection(member_id) or \
                     websocket_manager.has_connection(member_id)
    # 3. 两者都满足才认为在线
    return is_online_db and has_connection
```

2. **消息通道选择**：
```python
# 根据状态选择通道
if recipient_online and has_connection:
    # 在线：实时推送
    await sse_manager.send_message(message)
    mark_delivered = True
else:
    # 离线：保存到数据库
    save_to_db(message, delivered=False)
    mark_delivered = False
```

## 注意事项

1. **状态同步**：
   - 前端状态更新后，需要等待后端确认
   - 下拉列表刷新时，可能有短暂延迟

2. **性能优化**：
   - 下拉列表刷新使用缓存，避免频繁请求
   - 状态查询使用批量接口，减少请求次数

3. **错误处理**：
   - 状态更新失败时，静默处理，不影响用户体验
   - 网络错误时，使用缓存状态

