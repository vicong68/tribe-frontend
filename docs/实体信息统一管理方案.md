# 实体信息统一管理方案

## 问题分析

### 当前问题

1. **ID 和名称混淆**：
   - 用户ID：`memberId`（后端）、`userId`（前端）、`email`（可能作为ID）
   - Agent ID：`agent_id`（内部）、`display_name`（显示名称）
   - 前后端不统一，容易混淆

2. **信息分散**：
   - Agent 信息分散在：AgentRegistry、配置文件、数据库
   - 用户信息分散在：数据库 members 表、AgentRegistry 的 user_display_by_id
   - 每次查询都需要访问多个数据源

3. **查询效率低**：
   - 每次列表查询都要访问数据库
   - 没有统一的缓存机制
   - 重复查询相同信息

4. **关联关系不清晰**：
   - `memberId`（后端数据库）和 `userId`（前端数据库）的关联关系不明确
   - 显示名称到ID的映射关系分散

## 解决方案

### 1. 统一信息管理器（EntityInfoManager）

**位置**：`tribe-backend/utils/entity_info_manager.py`

**功能**：
- 运行时维护 Agent 和 User 的完整信息表
- 提供统一的查询接口
- 支持多种查询方式（ID、显示名称、前端ID）
- 自动同步数据库和注册中心的变化

**数据结构**：
```python
@dataclass
class AgentEntityInfo:
    agent_id: str  # 内部ID（如 "chat", "rag"）
    display_names: List[str]  # 显示名称列表
    primary_display_name: str  # 主显示名称
    description: str
    category: Optional[str]
    model_provider: Optional[str]
    model_id: Optional[str]
    tools: List[Dict]
    knowledge: Optional[str]
    status: str  # online, offline, busy
    is_registered: bool
    last_updated: datetime

@dataclass
class UserEntityInfo:
    member_id: str  # 后端用户ID（数据库主键）
    display_name: str  # 显示名称（昵称）
    email: Optional[str]
    is_online: bool
    last_seen_at: Optional[datetime]
    last_login_at: Optional[datetime]
    user_group: Optional[str]
    introduction: Optional[str]
    created_at: Optional[datetime]
    frontend_user_id: Optional[str]  # 前端数据库的UUID
    last_updated: datetime
```

**索引结构**：
- `_agents: Dict[str, AgentEntityInfo]` - agent_id -> AgentEntityInfo
- `_users: Dict[str, UserEntityInfo]` - member_id -> UserEntityInfo
- `_agent_display_to_id: Dict[str, str]` - display_name -> agent_id
- `_user_display_to_id: Dict[str, str]` - display_name -> member_id
- `_frontend_to_backend: Dict[str, str]` - frontend_user_id -> member_id

### 2. 统一 API 接口

**位置**：`tribe-backend/api/entity_info_routes.py`

**接口设计**：

1. **简要信息API**（用于列表显示）：
   - `GET /api/entity/summary?entity_type=agent|user&refresh=false`
   - 返回简要信息，减少数据传输
   - 支持按类型过滤

2. **完整信息API**（用于详情查询）：
   - `GET /api/entity/agent/{agent_id}?refresh=false`
   - `GET /api/entity/user/{member_id}?refresh=false`
   - 返回完整信息，包含所有配置和状态

3. **缓存刷新API**：
   - `POST /api/entity/refresh`
   - 手动刷新缓存（用户登录/注销、配置更新后调用）

### 3. 前端统一客户端

**位置**：`tribe-frontend/lib/entity-info-client.ts`

**功能**：
- 统一的类型定义（AgentSummary、UserSummary、AgentDetail、UserDetail）
- 统一的查询函数
- 支持缓存刷新

### 4. 自动同步机制

**用户状态更新**：
- `user_base.mark_online()` 和 `mark_offline()` 自动同步到 EntityInfoManager
- 无需手动刷新，保证数据一致性

**Agent 信息更新**：
- 通过 `refresh_agents()` 方法从注册中心和配置文件加载
- 支持手动刷新和自动刷新

## 使用示例

### 后端使用

```python
from utils.entity_info_manager import get_entity_info_manager

# 获取管理器
manager = get_entity_info_manager()

# 刷新信息
manager.refresh_agents(registry, agent_configs)
manager.refresh_users(user_base)

# 查询 Agent
agent = manager.get_agent_by_id("chat")
agent = manager.get_agent_by_display_name("司仪")

# 查询 User
user = manager.get_user_by_member_id("user123")
user = manager.get_user_by_display_name("张三")
user = manager.get_user_by_frontend_id("uuid-xxx")

# 获取简要列表
agents_summary = manager.list_agents_summary()
users_summary = manager.list_users_summary()

# 获取完整信息
agent_detail = manager.get_agent_detail("chat")
user_detail = manager.get_user_detail("user123")
```

### 前端使用

```typescript
import { fetchEntitiesSummary, fetchAgentDetail, fetchUserDetail } from "@/lib/entity-info-client";

// 获取简要列表（用于下拉菜单）
const { agents, users } = await fetchEntitiesSummary();

// 获取完整信息（用于详情页）
const agentDetail = await fetchAgentDetail("chat");
const userDetail = await fetchUserDetail("user123");

// 强制刷新缓存
await refreshEntitiesCache();
```

## 关联关系说明

### memberId 和 userId 的关系

1. **memberId**（后端）：
   - 存储在 `members` 表的 `member_id` 字段
   - 是后端数据库的主键
   - 用于后端所有业务逻辑

2. **userId**（前端）：
   - 存储在前端数据库的 `users` 表的 `id` 字段
   - 是前端数据库的 UUID
   - 用于前端会话管理和权限控制

3. **关联关系**：
   - 通过 `EntityInfoManager._frontend_to_backend` 维护
   - 在用户登录时建立关联
   - 支持通过前端ID查询后端信息

### 显示名称到ID的映射

1. **Agent**：
   - `display_name`（如 "司仪"）-> `agent_id`（如 "chat"）
   - 存储在 `_agent_display_to_id` 中
   - 支持多个显示名称映射到同一个ID

2. **User**：
   - `display_name`（昵称）-> `member_id`
   - 存储在 `_user_display_to_id` 中
   - 支持通过昵称查询用户

## 迁移计划

### 阶段1：基础架构（已完成）
- ✅ 创建 EntityInfoManager
- ✅ 创建统一 API 接口
- ✅ 创建前端客户端

### 阶段2：集成现有代码
- ⏳ 更新 `agents_routes.py` 使用 EntityInfoManager
- ⏳ 更新前端 `models-client.ts` 使用新的 API
- ⏳ 更新用户状态更新逻辑

### 阶段3：优化和清理
- ⏳ 移除重复的查询逻辑
- ⏳ 统一前后端数据模型
- ⏳ 完善文档和测试

## 优势

1. **统一性**：
   - 单一数据源，避免不一致
   - 统一的查询接口
   - 统一的数据模型

2. **性能**：
   - 运行时缓存，避免重复查询
   - 简要信息API减少数据传输
   - 支持按需刷新

3. **可维护性**：
   - 清晰的关联关系
   - 统一的错误处理
   - 易于扩展

4. **灵活性**：
   - 支持多种查询方式
   - 支持手动和自动刷新
   - 向后兼容现有API

